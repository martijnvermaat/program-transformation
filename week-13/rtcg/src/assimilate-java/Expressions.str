module assimilate-java/Expressions
imports
  assimilate-java/Util

rules

  /**
   * Assimilate decimal constant.
   * todo: Is this correct wrt typing?
   */
  Assimilate(s) :
    e |[ i ]| -> bstm* |[ thisCode.emitPushInt(i); ]|

  /**
   * Assimilate boolean constant.
   */
  Assimilate(s) :
    e |[ true ]| -> bstm* |[ thisCode.emitPushInt(1); ]|

  Assimilate(s) :
    e |[ false ]| -> bstm* |[ thisCode.emitPushInt(0); ]|

  /**
   * Assimilate local variable.
   */
  Assimilate(s) :
    e |[ x ]| -> bstm* |[ thisCode.emitLoad( ~var ); ]|
    where !ExprName(Id( <LocalVar> x )) => var

  /**
   * Assimilate undercover local variable.
   * We kinda stretch the use of dryad, and it sometimes recognizes local
   * variables as if they are fields. Therefore we handle fields like they
   * are local variables. We don't support real fields anyway.
   */
  Assimilate(s) :
    Field(Id(x)) -> bstm* |[ thisCode.emitLoad( ~var ); ]|
    where !ExprName(Id( <LocalVar> x )) => var

  /**
   * Assimilate post-increment of local variable.
   * todo: Doesn't emitInc push the result on the stack for us?
   */
  Assimilate(s) :
    e |[ x++ ]| -> bstm* |[ thisCode.emitInc( ~var , (short)1 );
                             thisCode.emitLoad( ~var ); ]|
    where !ExprName(Id( <LocalVar> x )) => var

  /**
   * Assimilate post-decrement of local variable.
   */
  Assimilate(s) :
    e |[ x-- ]| -> bstm* |[ thisCode.emitInc( ~var , (short)-1 );
                             thisCode.emitLoad( ~var ); ]|
    where !ExprName(Id( <LocalVar> x )) => var

  /**
   * Assimilate binary operator.
   * todo: Use PrimType argument, eg Type.int_type for emitAdd method. This is
   * actually quite nasty, because Java expects us to do implicit casts, for
   * example 5 + 4l is a long-add with a conversion from int to long on the
   * first number. We won't do things like this.
   */
  Assimilate(s) :
    op#([e1, e2]) -> bstm* |[ ~*operands
                              thisCode.~method(); ]|
    where   <assimilate-operator> op => method
          ; <concat> [ <s> e1
                     , <s> e2 ] => operands

  /**
   * Assimilate > operator.
   * There are no booleans in bytecode. They are just 0 and 1 integers.
   */
  Assimilate(s) :
    e |[ e1 > e2 ]| -> bstm* |[ ~*operands
                                thisCode.emitIfGt();
                                thisCode.pushInt(1);
                                thisCode.emitElse();
                                thisCode.pushInt(0);
                                thisCode.emitFi(); ]|
    where <concat> [ <s> e1
                   , <s> e2 ] => operands

  /**
   * Assimilate < operator.
   * There are no booleans in bytecode. They are just 0 and 1 integers.
   */
  Assimilate(s) :
    e |[ e1 < e2 ]| -> bstm* |[ ~*operands
                                thisCode.emitIfLt();
                                thisCode.pushInt(1);
                                thisCode.emitElse();
                                thisCode.pushInt(0);
                                thisCode.emitFi(); ]|
    where <concat> [ <s> e1
                   , <s> e2 ] => operands

  /**
   * Assimilate assignment.
   */
  Assimilate(s) :
    e |[ x = e ]| -> bstm* |[ ~*< <s> e >
                              thisCode.emitDup();
                              thisCode.emitStore( ~var ); ]|
    where !ExprName(Id( <LocalVar> x )) => var

  /**
   * Assimilate assignment where lefthand-side is an undercover variable.
   */
  Assimilate(s) :
    e |[ ~Field(Id(x)) = e ]| -> bstm* |[ ~*< <s> e >
                                    thisCode.emitDup();
                                    thisCode.emitStore( ~var ); ]|
    where !ExprName(Id( <LocalVar> x )) => var

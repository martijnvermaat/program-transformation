module assimilate-java/Classes
imports
  assimilate-java/Util
  assimilate-java/Statements

/**
 * todo: Generated statements in concrete syntax are often ambiguous (in the
 * qualification part), but we ignore this. Pretty printing will 'just' fix
 * it, but a better solution would be to define some often-used qualifications
 * toplevel using abstract syntax. The test suite would also have to be fixed,
 * because it also contains these ambiguities.
 */

rules

  /**
   * Assimilate class declaration.
   */
  Assimilate(s) =
    ?ClassDec(head, body)
    ; <mapconcat(s)>[head, body]

  /**
   * Assimilate class declaration head.
   * todo: Annotations, type parameters, interfaces.
   * todo: Should we generate empty constructor if none is given?
   */
  Assimilate(s) =
    ?ClassDecHead(mods, name, type-params, super, interfaces)
    ; <concat> [ <assimilate-class-name>      name
               , <assimilate-class-modifiers> mods
               , <assimilate-class-super>     super ]

  /**
   * Assimilate class declaration body.
   */
  Assimilate(s) =
    ?ClassBody(decs)
    ; <mapconcat(s)> decs

  /**
   * Assimilate method declaration.
   * todo: Generate return statement for void methods.
   * todo: Block scope is a hack, maybe do thisCode and thisMethod declaration
   *       only once (in java-bytecode-assimilation) and scope block of entire
   *       class dec.
   */
  Assimilate(s) =
    ?MethodDec(head, body)
    ; !bstm* |[ ~*< <s> head >
                thisCode.pushScope();
                ~*< <s> body >
                thisCode.popScope(); ]|

  /**
   * Assimilate method declaration head.
   * todo: Annotations, type parameters, throws.
   */
  Assimilate(s) =
    ?MethodDecHead(mods, type-params, result-type, name, params, throws)
    ; <concat> [ <assimilate-method-name>      name
               , <assimilate-method-sig>       (params, result-type)
               , <assimilate-method-modifiers> mods
               , <generate-method-init>
               , <assimilate-method-params>    params ]

  /**
   * Assimilate empty method declaration body.
   */
  Assimilate(s) :
    NoMethodBody -> []

strategies

  assimilate-class-name =
   ?Id(name)
   ; !Lit(String([Chars(name)]))
   ; !bstm* |[ thisClass = new ClassType(~<id>); ]|

  /**
   * Generate statement setting modifiers from list of modifiers.
   * See assimilate-method-modifiers below for an example.
   */
  assimilate-class-modifiers =
    if ?[] then ![] else
      foldr(!Lit(Deci("0")), combine-modifiers, assimilate-modifier)
      ; !bstm* |[ thisClass.setModifiers( ~<id> ); ]|
    end

  /**
   * Create a string from a superclass definition and use this in a setSuper
   * call.
   * todo: This is a hack.
   * todo: use dryad get-super and similar?
   */
  assimilate-class-super =
    if ?None then
      !"java.lang.Object"
    else
      collect(is-string)
      ; separate-by(|".")
      ; foldr(!"", conc-strings)
    end
    ; !bstm* |[ thisClass.setSuper( ~<!Lit(String([Chars(<id>)]))> ); ]|

  assimilate-method-name =
    ?Id(name)
    ; !Lit(String([Chars(name)]))
    ; !bstm* |[ thisMethod = thisClass.addMethod(~<id>); ]|

  /**
   * Generate a method signature from parameters and return type.
   * Example:
   *   ([Param(_, Boolean, _), Param(_, Int, _)], void) -> "(ZI)V"
   * todo: non-primitive types
   */
  assimilate-method-sig = 
    ?(params, return)
    ; <concat-strings> [ "("
                       , <process-method-sig-params> params
                       , ")"
                       , <assimilate-descriptor> return ]
    ; !Lit(String([Chars(<id>)]))
    ; !bstm* |[ thisMethod.setSignature( ~<id> ); ]|

  /**
   * Get a string with type descriptors separated by commas.
   */
  process-method-sig-params =
    map(get-parameter-type; assimilate-descriptor)
    ; separate-by(|",")
    ; concat-strings

  /**
   * Extract type from method parameter.
   */
  get-parameter-type :
    Param(_, t, _) -> t

  /**
   * Generate statement setting modifiers from list of modifiers.
   * Example:
   *   [Public, Static] -> |[ thisMethod.setModifiers(
                                Access.PUBLIC | (Access.STATIC | 0)
                              ) ]|
   */
  assimilate-method-modifiers =
    if ?[] then ![] else
      foldr(!Lit(Deci("0")), combine-modifiers, assimilate-modifier)
      ; !bstm* |[ thisMethod.setModifiers( ~<id> ); ]|
    end

  /**
   * Generate initialization statements for method declaration.
   */
  generate-method-init =
    !bstm* |[ thisMethod.initCode();
              thisCode = thisMethod.getCode(); ]|

  /**
   * Generate statements for declaring method parameters.
   */
  assimilate-method-params =
    mapconcat(assimilate-method-param)

  /**
   * Generate statement for declaring method parameter.
   * todo: Modifiers, variable arity parameter?
   * todo: Scope LocalVar rule somewhere.
   * todo: De-uglify, move rules() and <new> to separate strategy.
   * todo: Combine with local variable declarations.
   */
  assimilate-method-param =
    ?Param(_, type, Id(name))
    ; !Lit(String([Chars(name)])) => bytevar
    ; <newname> "var" => var
    ; <assimilate-type> type => vartype
    ; !bstm* |[ Variable ~<!Id(var)> =
                  thisCode.addLocal(~vartype, ~bytevar); ]|
    ; rules (
        LocalVar : name -> var
      )

module assimilate-java/Classes
imports
  Java-EBlock

/**
 * todo: Generated statements in concrete syntax are often ambiguous (in the
 * qualification part), but we ignore this. Pretty printing will 'just' fix
 * it, but a better solution would be to define some often-used qualifications
 * toplevel using abstract syntax. The test suite would also have to be fixed,
 * because it also contains these ambiguities.
 */

rules

  /**
   * Assimilate class declaration.
   */
  Assimilate(s) =
    ?ClassDec(head, body)
    ; <mapconcat(s)>[head, body]

  /**
   * Assimilate class declaration head.
   * todo: Annotations, type parameters, interfaces.
   */
  Assimilate(s) =
    ?ClassDecHead(mods, name, type-params, super, interfaces)
    ; <concat> [ <assimilate-class-name>      name
               , <assimilate-class-modifiers> mods
               , <assimilate-class-super>     super ]

  /**
   * Assimilate class declaration body.
   */
  Assimilate(s) =
    ?ClassBody(decs)
    ; <mapconcat(s)> decs

  /**
   * Assimilate method declaration.
   * todo: Find out about scoping?
   */
  Assimilate(s) =
    ?MethodDec(head, body)
    ; <mapconcat(s)> [head, body]

  /**
   * Assimilate method declaration head.
   *
   * (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?
   *
   */
  Assimilate(s) =
    ?MethodDecHead(mods, type-params, result-type, name, params, throws)
    ; <concat> [ <assimilate-method-name> name
               , <assimilate-method-sig>  (params, result-type)
               , bstm* |[ thisMethod.initCode();
                          CodeAttr thisCode = thisMethod.getCode(); ]| ]

  /**
   * Assimilate empty method declaration body.
   */
  Assimilate(s) :
    NoMethodBody -> []

strategies

  assimilate-class-name =
   ?Id(name)
   ; !Lit(String([Chars(name)]))
   ; !bstm* |[ ClassType thisClass = new ClassType(~<id>); ]|

  assimilate-class-modifiers =
    if ?[] then ![] else
      foldr(!Lit(Deci("0")), combine-class-modifiers, assimilate-modifier)
      ; !bstm* |[ thisClass.setModifiers( ~<id> ); ]|
    end

  combine-class-modifiers :
    (mod, rest) -> Or(mod, rest)

  assimilate-modifier : Public    -> e |[ Access.PUBLIC    ]|
  assimilate-modifier : Private   -> e |[ Access.PRIVATE   ]|
  assimilate-modifier : Protected -> e |[ Access.PROTECTED ]|
  assimilate-modifier : Static    -> e |[ Access.STATIC    ]|
  assimilate-modifier : Final     -> e |[ Access.FINAL     ]|

  /**
   * Create a string from a superclass definition and use this in a setSuper
   * call.
   * todo: This is a hack.
   */
  assimilate-class-super =
    if ?None then ![] else
      collect(is-string)
      ; separate-by(|".")
      ; foldr(!"", conc-strings)
      ; !bstm* |[ thisClass.setSuper( ~<!Lit(String([Chars(<id>)]))> ); ]|
    end

  assimilate-method-name =
    ?Id(name)
    ; !Lit(String([Chars(name)]))
    ; !bstm* |[ Method thisMethod = thisClass.addMethod(~<id>); ]|

  /**
   * Generate a method signature from parameters and return type.
   * Example:
   *   ([Param(_, Boolean, _), Param(_, Int, _)], void) -> "(ZI)V"
   * todo: non-primitive types
   */
  assimilate-method-sig = 
    ?(params, return)
    ; <concat-strings> [ "("
                       , <process-method-sig-params> params
                       , ")"
                       , <assimilate-descriptor> return ]
    ; !Lit(String([Chars(<id>)]))
    ; !bstm* |[ thisMethod.setSignature( ~<id> ); ]|

  /**
   * Get a string with type descriptors separated by commas.
   */
  process-method-sig-params =
    map(get-parameter-type; assimilate-descriptor)
    ; separate-by(|",")
    ; concat-strings

  /**
   * Extract type from method parameter.
   */
  get-parameter-type :
    Param(_, t, _) -> t

  assimilate-descriptor : Void    -> "V"
  assimilate-descriptor : Boolean -> "Z"
  assimilate-descriptor : Byte    -> "B"
  assimilate-descriptor : Short   -> "S"
  assimilate-descriptor : Int     -> "I"
  assimilate-descriptor : Long    -> "J"
  assimilate-descriptor : Char    -> "C"
  assimilate-descriptor : Float   -> "F"
  assimilate-descriptor : Double  -> "D"

module assimilate-java/test
imports
  libstrategolib
  libdryad
  assimilate-java/Classes
  assimilate-java/Statements
  assimilate-java/Expressions

strategies

  main =
    option-wrap(general-options,
      test-suite(!"assimilate-java-test",
        observables-wrap(
            test-expressions
          ; test-statements
          ; test-method-decs
          ; test-class-decs
        )
      )
    )

  test-expressions = id

    ; apply-test(!"Simple literal",
      assimilate,
      !e |[ 1 ]|,
      !bstm* |[ thisCode.emitPushInt(1); ]|
    )
    ; apply-test(!"Simple literal",
      assimilate,
      !e |[ 3 ]|,
      !bstm* |[ thisCode.emitPushInt(3); ]|
    )
    ; apply-test(!"Simple literal addition",
      assimilate,
      !e |[ 4 + 7 ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitPushInt(7);
                thisCode.emitAdd(); ]|
    )
    ; apply-test(!"Simple literal multiplication",
      assimilate,
      !e |[ 7 * 2 ]|,
      !bstm* |[ thisCode.emitPushInt(7);
                thisCode.emitPushInt(2);
                thisCode.emitMul(); ]|
    )
    ; apply-test(!"Simple literal division",
      assimilate,
      !e |[ 12 / 9 ]|,
      !bstm* |[ thisCode.emitPushInt(12);
                thisCode.emitPushInt(9);
                thisCode.emitDiv(); ]|
    )
    ; apply-test(!"Complex arithmetic with literals",
      assimilate,
      !e |[ (4 + 12 / 2) - 5 ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitPushInt(12);
                thisCode.emitPushInt(2);
                thisCode.emitDiv();
                thisCode.emitAdd();
                thisCode.emitPushInt(5);
                thisCode.emitSub(); ]|
    )

  test-statements = id

    ; apply-test(!"Empty statement",
      assimilate,
      !bstm |[ ; ]|,
      ![]
    )
    ; apply-test(!"Block of empty statements",
      assimilate,
      !bstm |[ { ; ; ; ; } ]|,
      ![]
    )
    ; apply-test(!"Expression statement",
      assimilate,
      !bstm |[ 37; ]|,
      !bstm* |[ thisCode.emitPushInt(37);
                thisCode.emitPop(1); ]|
    )

  test-method-decs = id

    ; apply-test(!"Simple method declaration",
      assimilate,
      !class-body-dec |[ void hoi() { } ]|,
      !bstm* |[ Method thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.initCode();
                CodeAttr thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.popScope(); ]|
    )
    ; apply-and-check(!"Method declaration with parameter",
      assimilate,
      !class-body-dec |[ void test(int m) { } ]|,
      /* Here we use a match, because we don't know what the variables will be
         named. */
      ?bstm* |[ Method thisMethod = thisClass.addMethod("test");
                thisMethod.setSignature("(I)V");
                thisMethod.initCode();
                CodeAttr thisCode = thisMethod.getCode();
                Variable ~var = thisCode.addLocal(Type.int_type, "m");
                thisCode.pushScope();
                thisCode.popScope(); ]|
    )
    ; apply-and-check(!"Method declaration with parameters and return type",
      assimilate,
      !class-body-dec |[ int test(boolean n, int m) { } ]|,
      ?bstm* |[ Method thisMethod = thisClass.addMethod("test");
                thisMethod.setSignature("(Z,I)I");
                thisMethod.initCode();
                CodeAttr thisCode = thisMethod.getCode();
                Variable ~var1 = thisCode.addLocal(Type.boolean_type, "n");
                Variable ~var2 = thisCode.addLocal(Type.int_type, "m");
                thisCode.pushScope();
                thisCode.popScope(); ]|
    )
    ; apply-test(!"Method declaration with modifier",
      assimilate,
      !class-body-dec |[ public void hoi() { } ]|,
      !bstm* |[ Method thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.setModifiers(Access.PUBLIC | 0);
                thisMethod.initCode();
                CodeAttr thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.popScope(); ]|
    )
    ; apply-test(!"Method declaration with modifiers",
      assimilate,
      !class-body-dec |[ public static void hoi() { } ]|,
      !bstm* |[ Method thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.setModifiers(Access.PUBLIC | (Access.STATIC | 0));
                thisMethod.initCode();
                CodeAttr thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.popScope(); ]|
    )
    ; apply-test(!"Simple method declaration with expression statement",
      assimilate,
      !class-body-dec |[ void hoi() { 4; } ]|,
      !bstm* |[ Method thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.initCode();
                CodeAttr thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.emitPushInt(4);
                thisCode.emitPop(1);
                thisCode.popScope(); ]|
    )

  test-class-decs = id

    ; test-classdec(
        id
      | "Simple class declaration"
      , type-dec |[ class Test1 { } ]|
      )
    ; test-classdec(|"Simple class declaration"
      , type-dec |[ class Test2 { } ]|
      , bstm* |[ ClassType thisClass = new ClassType("Test2"); ]|
      )
    ; test-classdec(|"Class declaration with modifiers"
      , type-dec |[ public class Test2 { } ]|
      , bstm* |[ ClassType thisClass = new ClassType("Test2");
                 thisClass.setModifiers(Access.PUBLIC | 0); ]|
      )
    ; test-classdec(|"Class declaration with modifiers"
      , type-dec |[ public final class Test2 { } ]|
      , bstm* |[ ClassType thisClass = new ClassType("Test2");
                 thisClass.setModifiers(Access.PUBLIC | (Access.FINAL | 0)); ]|
      )
    ; test-classdec(|"Class declaration with super"
      , type-dec |[ class Test2 extends Object { } ]|
      , bstm* |[ ClassType thisClass = new ClassType("Test2");
                 thisClass.setSuper("java.lang.Object"); ]|
      )

strategies

  assimilate =
    Assimilate(assimilate)

strategies

  test-classdec(check |msg, src) =
    apply-and-check(!msg
    , assimilate
    , <process-input> [CompilationUnit(None, [], [src])]
      ; collect(?ClassDec(_, _))
      ; ?[<id>]
    , check
    )

  test-classdec(|msg, src, result) =
    apply-test(!msg
    , assimilate
    , <process-input> [CompilationUnit(None, [], [src])]
      ; collect(?ClassDec(_, _))
      ; ?[<id>]
    , !result
    )

  process-input =
    map(define-compilation-unit)
    ; dryad-reclassify
    ; map(dryad-type-checker) 
    ; last
    ; get-ast

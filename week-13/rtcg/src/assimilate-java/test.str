module assimilate-java/test
imports
  libstrategolib
  libdryad
  assimilate-java/Classes
  assimilate-java/Statements
  assimilate-java/Expressions

strategies

  main =
    option-wrap(general-options,
      test-suite(!"assimilate-java-test",
        observables-wrap(
            test-expressions
          ; test-statements
          ; test-method-decs
          ; test-class-decs
        )
      )
    )

  test-expressions = id

    ; apply-test(!"Simple literal int",
      assimilate,
      !e |[ 1 ]|,
      !bstm* |[ thisCode.emitPushInt(1); ]|
    )
    ; apply-test(!"Simple literal int",
      assimilate,
      !e |[ 3 ]|,
      !bstm* |[ thisCode.emitPushInt(3); ]|
    )
    ; apply-test(!"Simple literal boolean",
      assimilate,
      !e |[ true ]|,
      !bstm* |[ thisCode.emitPushInt(1); ]|
    )
    ; apply-test(!"Simple literal boolean",
      assimilate,
      !e |[ false ]|,
      !bstm* |[ thisCode.emitPushInt(0); ]|
    )
    ; apply-test(!"Simple literal addition",
      assimilate,
      !e |[ 4 + 7 ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitPushInt(7);
                thisCode.emitAdd(); ]|
    )
    ; apply-test(!"Simple literal multiplication",
      assimilate,
      !e |[ 7 * 2 ]|,
      !bstm* |[ thisCode.emitPushInt(7);
                thisCode.emitPushInt(2);
                thisCode.emitMul(); ]|
    )
    ; apply-test(!"Simple literal division",
      assimilate,
      !e |[ 12 / 9 ]|,
      !bstm* |[ thisCode.emitPushInt(12);
                thisCode.emitPushInt(9);
                thisCode.emitDiv(); ]|
    )
    ; apply-test(!"Complex arithmetic with literals",
      assimilate,
      !e |[ (4 + 12 / 2) - 5 ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitPushInt(12);
                thisCode.emitPushInt(2);
                thisCode.emitDiv();
                thisCode.emitAdd();
                thisCode.emitPushInt(5);
                thisCode.emitSub(); ]|
    )
    ; apply-test(!"Simple post-increment",
      assimilate,
      rules ( LocalVar : "var555" -> "var_0" )
      ; !e |[ var555++ ]|,
      !bstm* |[ thisCode.emitInc(var_0, (short)1);
                thisCode.emitLoad(var_0); ]|
    )
    ; apply-test(!"Simple post-increment of field",
      assimilate,
      rules ( LocalVar : "var757" -> "var_0" )
      ; !PostIncr(Field(Id("var757"))),
      !bstm* |[ thisCode.emitInc(var_0, (short)1);
                thisCode.emitLoad(var_0); ]|
    )
    ; apply-test(!"Simple post-decrement",
      assimilate,
      rules ( LocalVar : "var556" -> "var_0" )
      ; !e |[ var556-- ]|,
      !bstm* |[ thisCode.emitInc(var_0, (short)-1);
                thisCode.emitLoad(var_0); ]|
    )
    ; apply-test(!"Simple post-decrement of field",
      assimilate,
      rules ( LocalVar : "var756" -> "var_0" )
      ; !PostDecr(Field(Id("var756"))),
      !bstm* |[ thisCode.emitInc(var_0, (short)-1);
                thisCode.emitLoad(var_0); ]|
    )
    ; apply-test(!"Simple assignment",
      assimilate,
      rules ( LocalVar : "var5434" -> "var_0" )
      ; !e |[ var5434 = 4 ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitDup();
                thisCode.emitStore(var_0); ]|
    )
    ; apply-test(!"Simple assignment to field",
      assimilate,
      rules ( LocalVar : "var7665" -> "var_0" )
      ; !Assign(Field(Id("var7665")),Lit(Deci("1"))),
      !bstm* |[ thisCode.emitPushInt(1);
                thisCode.emitDup();
                thisCode.emitStore(var_0); ]|
    )
    ; apply-test(!"Assignment of expression",
      assimilate,
      rules ( LocalVar : "var5435" -> "var_0"
              LocalVar : "var5436" -> "var_1" )
      ; !e |[ var5435 =  78 + var5436 ]|,
      !bstm* |[ thisCode.emitPushInt(78);
                thisCode.emitLoad(var_1);
                thisCode.emitAdd();
                thisCode.emitDup();
                thisCode.emitStore(var_0); ]|
    )
    ; apply-test(!"Simple gt check",
      assimilate,
      !e |[ 456 > 34 ]|,
      !bstm* |[ thisCode.emitPushInt(456);
                thisCode.emitPushInt(34);
                thisCode.emitIfGt();
                thisCode.emitPushInt(1);
                thisCode.emitElse();
                thisCode.emitPushInt(0);
                thisCode.emitFi(); ]|
    )
    ; apply-test(!"Simple lt check",
      assimilate,
      !e |[ 456 < 34 ]|,
      !bstm* |[ thisCode.emitPushInt(456);
                thisCode.emitPushInt(34);
                thisCode.emitIfLt();
                thisCode.emitPushInt(1);
                thisCode.emitElse();
                thisCode.emitPushInt(0);
                thisCode.emitFi(); ]|
    )

  test-statements = id

    ; apply-test(!"Empty statement",
      assimilate,
      !bstm |[ ; ]|,
      ![]
    )
    ; apply-test(!"Block of empty statements",
      assimilate,
      !bstm |[ { ; ; ; ; } ]|,
      ![]
    )
    ; apply-test(!"Expression statement",
      assimilate,
      !bstm |[ 37; ]|,
      !bstm* |[ thisCode.emitPushInt(37);
                thisCode.emitPop(1); ]|
    )
    /* Here we use a match, because we don't know what the variables will be
       named. */
    ; apply-and-check(!"Local variable declaration",
      assimilate,
      !bstm |[ int n; ]|,
      ?bstm* |[ Variable ~x1 = thisCode.addLocal(Type.int_type, "n"); ]|
    )
    ; apply-and-check(!"Local variable declaration",
      assimilate,
      !bstm |[ int n; ]|,
      <LocalVar> "n"
    )
    ; apply-and-check(!"Local variable declaration and use",
      assimilate,
      !bstm |[ { int n; n; } ]|,
      ?bstm* |[ Variable ~x2 = thisCode.addLocal(Type.int_type, "n");
                thisCode.emitLoad( ~<!ExprName(x2)> );
                thisCode.emitPop(1); ]|
    )
    ; apply-test(!"Use of local variable",
      assimilate,
      rules ( LocalVar : "var7663" -> "var_0" )
      ; !ExprName(Id("var7663")),
      !bstm* |[ thisCode.emitLoad(var_0); ]|
    )
    ; apply-test(!"Use of local variable (field version)",
      assimilate,
      rules ( LocalVar : "var7664" -> "var_0" )
      ; !Field(Id("var7664")),
      !bstm* |[ thisCode.emitLoad(var_0); ]|
    )
    ; apply-test(!"Return statement",
      assimilate,
      !bstm |[ return; ]|,
      !bstm* |[ thisCode.emitReturn(); ]|
    )
    ; apply-test(!"Return statement with value",
      assimilate,
      !bstm |[ return 4; ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitReturn(); ]|
    )
    ; apply-test(!"Return statement with expression",
      assimilate,
      !bstm |[ return 4 + 2; ]|,
      !bstm* |[ thisCode.emitPushInt(4);
                thisCode.emitPushInt(2);
                thisCode.emitAdd();
                thisCode.emitReturn(); ]|
    )
    ; apply-and-check(!"Simple do-while loop",
      assimilate,
      !bstm |[ do 5; while(true); ]|,
      ?bstm* |[ Label ~x10 = new Label(thisCode);
                ~<!x10>.define(thisCode);
                thisCode.emitPushInt(5);
                thisCode.emitPop(1);
                thisCode.emitPushInt(1);
                thisCode.emitPushInt(0);
                thisCode.emitGotoIfGt( ~<!ExprName(x10)> ); ]|
    )

  test-method-decs = id

    ; apply-test(!"Simple method declaration",
      assimilate,
      !class-body-dec |[ void hoi() { } ]|,
      !bstm* |[ thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )
    ; apply-and-check(!"Method declaration with parameter",
      assimilate,
      !class-body-dec |[ void test(int m) { } ]|,
      ?bstm* |[ thisMethod = thisClass.addMethod("test");
                thisMethod.setSignature("(I)V");
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                Variable ~var = thisCode.addLocal(Type.int_type, "m");
                thisCode.pushScope();
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )
    ; apply-and-check(!"Method declaration with parameter",
      assimilate,
      !class-body-dec |[ void test(int m) { m; } ]|,
      ?bstm* |[ thisMethod = thisClass.addMethod("test");
                thisMethod.setSignature("(I)V");
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                Variable ~x = thisCode.addLocal(Type.int_type, "m");
                thisCode.pushScope();
                thisCode.emitLoad( ~<!ExprName(x)> );
                thisCode.emitPop(1);
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )
    ; apply-and-check(!"Method declaration with parameters and return type",
      assimilate,
      !class-body-dec |[ int test(boolean n, int m) { } ]|,
      ?bstm* |[ thisMethod = thisClass.addMethod("test");
                thisMethod.setSignature("(Z,I)I");
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                Variable ~var1 = thisCode.addLocal(Type.boolean_type, "n");
                Variable ~var2 = thisCode.addLocal(Type.int_type, "m");
                thisCode.pushScope();
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )
    /* We need reclassification here for reference type. */
    ; test-classdec(|"Method declaration with non-primitive return type"
      , type-dec |[ class Testje { String test() { } } ]|
      , bstm* |[ thisClass = new ClassType("Testje");
                 thisClass.setSuper("java.lang.Object");
                 thisMethod = thisClass.addMethod("test");
                 thisMethod.setSignature("(Z,I)Ljava/lang/String;");
                 thisMethod.initCode();
                 thisCode = thisMethod.getCode();
                 thisCode.pushScope();
                 thisCode.emitReturn();
                 thisCode.popScope(); ]|
      )
    ; apply-test(!"Method declaration with modifier",
      assimilate,
      !class-body-dec |[ public void hoi() { } ]|,
      !bstm* |[ thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.setModifiers(Access.PUBLIC | 0);
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )
    ; apply-test(!"Method declaration with modifiers",
      assimilate,
      !class-body-dec |[ public static void hoi() { } ]|,
      !bstm* |[ thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.setModifiers(Access.PUBLIC | (Access.STATIC | 0));
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )
    ; apply-test(!"Simple method declaration with expression statement",
      assimilate,
      !class-body-dec |[ void hoi() { 4; } ]|,
      !bstm* |[ thisMethod = thisClass.addMethod("hoi");
                thisMethod.setSignature("()V");
                thisMethod.initCode();
                thisCode = thisMethod.getCode();
                thisCode.pushScope();
                thisCode.emitPushInt(4);
                thisCode.emitPop(1);
                thisCode.emitReturn();
                thisCode.popScope(); ]|
    )

  test-class-decs = id

    ; test-classdec(
        id /* todo: Reminder for other testcall, remove later. */
      | "Simple class declaration"
      , type-dec |[ class Test1 { } ]|
      )
    ; test-classdec(|"Simple class declaration"
      , type-dec |[ class Test2 { } ]|
      , bstm* |[ thisClass = new ClassType("Test2");
                 thisClass.setSuper("java.lang.Object"); ]|
      )
    ; test-classdec(|"Class declaration with modifiers"
      , type-dec |[ public class Test2 { } ]|
      , bstm* |[ thisClass = new ClassType("Test2");
                 thisClass.setModifiers(Access.PUBLIC | 0);
                 thisClass.setSuper("java.lang.Object"); ]|
      )
    ; test-classdec(|"Class declaration with modifiers"
      , type-dec |[ public final class Test2 { } ]|
      , bstm* |[ thisClass = new ClassType("Test2");
                 thisClass.setModifiers(Access.PUBLIC | (Access.FINAL | 0));
                 thisClass.setSuper("java.lang.Object"); ]|
      )
    ; test-classdec(|"Class declaration with super"
      , type-dec |[ class Test2 extends java.lang.String { } ]|
      , bstm* |[ thisClass = new ClassType("Test2");
                 thisClass.setSuper("java.lang.String"); ]|
      )
    /* todo: Testing classes with methods. */

strategies

  assimilate =
    Assimilate(assimilate)

strategies

  test-classdec(check |msg, src) =
    apply-and-check(!msg
    , assimilate
    , <process-input> [CompilationUnit(None, [], [src])]
      ; collect(?ClassDec(_, _))
      ; ?[<id>]
    , check
    )

  test-classdec(|msg, src, result) =
    apply-test(!msg
    , assimilate
    , <process-input> [CompilationUnit(None, [], [src])]
      ; collect(?ClassDec(_, _))
      ; ?[<id>]
    , !result
    )

  process-input =
    map(define-compilation-unit)
    ; dryad-reclassify
    ; map(dryad-type-checker) 
    ; last
    ; get-ast

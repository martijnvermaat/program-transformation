module assimilate-java/Statements
imports
  Java-EBlock

rules

  /**
   * Block statement.
   */
  Assimilate(s) :
    Block(stm*) -> <mapconcat(s)> stm*

  /**
   * Empty statement.
   */
  Assimilate(s) :
    Empty -> []

  /**
   * Assimilate expression statement.
   *
   * The value of the expression might stay on the stack unnoticed. Problem is
   * that a store operation implicitly does a pop, so it depends if the
   * expression is an assignment or not.
   * Easiest solution is to do a dup before every assignment and pop after all
   * expression statements. This is not in the spirit of store, but it makes
   * assignments deeper inside expressions work.
   * The Java compiler is a bit smarter about this. It inserts a dup if it
   * sees that the assignment is deeper inside an expression.
   *
   * todo: Remember to do the dup at assignments and look out for other such
   *       cases.
   */
  Assimilate(s) =
    ?ExprStm(<id>)
    ; <concat> [ <s>
               , bstm* |[ thisCode.emitPop(1); ]| ]

  /**
   * Assimilate local variable declaration.
   */
  Assimilate(s) =
    ?LocalVarDecStm(LocalVarDec(_, type, <id>))
    ; mapconcat( assimilate-local-var-dec(|type) )

  /**
   * Assimilate simple local variable declaration.
   * todo: De-uglify, combine with method parameters.
   */
  assimilate-local-var-dec(|type) =
    ?VarDec(Id(name))
    ; !Lit(String([Chars(name)])) => bytevar
    ; new => var
    ; <assimilate-type> type => vartype
    ; !bstm* |[ Variable ~<!Id(var)> =
                  thisCode.addLocal(~vartype, ~bytevar); ]|
    ; rules (
        LocalVar : name -> var
      )

  /**
   * Assimilate local variable declaration with assignment.
   * todo: This strategy.
   */
  assimilate-local-var-dec(|type) =
    ?VarDec(Id(name), exp)
    ; ![]

rules

  /* todo: complete */
  assimilate-type : Boolean -> e |[ Type.boolean_type ]|
  assimilate-type : Int     -> e |[ Type.int_type     ]|

module typestate/States

signature
  constructors
    TypeState : Property -> TypeState
    UnInit    : Property
    Init      : Property
    Dunno     : Property
    Null      : Property
    NotNull   : Property
    MaybeNull : Property

strategies

  /**
   * Combining branches in control flow.
   */
  typestate-combine : (UnInit, UnInit)   -> UnInit
  typestate-combine : (Init, Init)       -> Init
  typestate-combine : (Init, UnInit)     -> Dunno
  typestate-combine : (UnInit, Init)     -> Dunno
  typestate-combine : (Dunno, _)         -> Dunno
  typestate-combine : (_, Dunno)         -> Dunno
  typestate-combine : (Null, Null)       -> Null
  typestate-combine : (NotNull, NotNull) -> NotNull
  typestate-combine : (NotNull, Null)    -> MaybeNull
  typestate-combine : (Null, NotNull)    -> MaybeNull
  typestate-combine : (MaybeNull, _)     -> MaybeNull
  typestate-combine : (_, MaybeNull)     -> MaybeNull

  /**
   * Combining call arguments to returned state.
   * In this configuration uninitialized typestates basically propagate to
   * the typestate of the invokation.
   * todo: for null-state this should be more sophisticated, now we just say
   *       that a method never returns null.
   *       we could return the left state instead of always NotNull and do
   *       some figuring out for the particular method in typestate-call-init.
   */
  typestate-call-combine : (Init, Init)           -> Init
  typestate-call-combine : (Dunno, Dunno)         -> Dunno
  typestate-call-combine : (Dunno, Init)          -> Dunno
  typestate-call-combine : (Init, Dunno)          -> Dunno
  typestate-call-combine : (UnInit, _)            -> UnInit
  typestate-call-combine : (Init, UnInit)         -> UnInit
  typestate-call-combine : (Dunno, UnInit)        -> UnInit
  typestate-call-combine : (NotNull, _)           -> NotNull
  typestate-call-combine : (MaybeNull, _)         -> NotNull
  typestate-call-combine : (Null, _)              -> NotNull
  typestate-call-combine : (Init, Null)           -> Init
  typestate-call-combine : (Init, MaybeNull)      -> Init
  typestate-call-combine : (Init, NotNull)        -> Init
  typestate-call-combine : (Dunno, Null)          -> Dunno
  typestate-call-combine : (Dunno, MaybeNull)     -> Dunno
  typestate-call-combine : (Dunno, NotNull)       -> Dunno
  typestate-call-init(|type) =
    if <?ClassType(_,_)>type <+ <?InterfaceType(_,_)>type then
      !NotNull
    else
      !Init
    end

  /**
   * Propagation of typestate in assignment. Like this:
   *   (state-before, state-of-expr) -> state-after
   *
   * You can do here whatever you want. For the moment the variable just gets
   * the state of the assigned expression.
   */
  typestate-assignment-rule : (_, s) -> s

  /**
   * Initial typestate for variable upon declaration.
   */
  typestate-declaration-init(|type) =
    if <?ClassType(_,_)>type <+ <?InterfaceType(_,_)>type then
      !Null
    else
      !UnInit
    end

  /**
   * A created instance is never null.
   */
  typestate-instance-init =
    !NotNull

strategies

  merge-Typestate(s1, s2) =
    dr-symbolic-merge(
      typestate-combine
      , Typestate
      , aux-Typestate(|(), ())
      , redef-Typestate, s1, s2
      | "Typestate" )

  redef-Typestate =
    ?(x, o); rules ( Typestate : x -> o )

strategies

  /* todo: move some of this to Util or something */

  dr-symbolic-merge(merge, call, aux, redef, s1, s2 | R) =
    where(
      dr-get-rule-set(|R) => rs2
      ; dr-start-change-set(|R)
    )
    ; s1
    ; where(
        dr-get-rule-set(|R) => rs1
        ; <dr-set-rule-set(|R)> rs2
        ; dr-start-change-set(|R)
      )
    ; s2
    ; dr-symbolic-merge-rulesets(merge, call, aux, redef | rs1, R)

  dr-symbolic-merge-rulesets(merge, call, aux, redef | rs1, R) =
    where(
      !rs1 => [ChangeSet(_, _, <id>) | _]
      ; hashtable-keys
      ; map(Snd
            ; !(<id>, <merge>(<dr-symbolic-lookup(aux|rs1)>, <call>))
            ; redef)
      ; dr-get-rule-set(|R) => rs2 => [ChangeSet(_, _, <id>) | _]
      ; hashtable-keys
      ; map(Snd
            ; !(<id>, <merge>(<dr-symbolic-lookup(aux|rs1)>, <call>))
            ; redef)
      ; dr-commit-change-set(|R)
    )

  dr-symbolic-lookup(aux|rs) =
    ?x; <dr-lookup-rule(|x)> rs; ?[<aux>|_]

module typestate/Rules
imports
  typestate/States

signature
  constructors
    Call : Expr * List(Expr) -> Expr

rules

  TypestateVar :
        ExprName(Id(var)){t*} -> ExprName(Id(var)){TypeState(ts), t*}
        where <Typestate>var => ts

  TypestateLiteral :
        Lit(l){t*} -> Lit(l){TypeState(Init), t*}

  TypestateCall :
        Call(f{t*}, e*) -> Call(f{TypeState(ts), t*}, e*)
        where <foldr(!Init, typestate-combine, typestate-of)> e* => ts

  TypestateVarAssignment :
        Assign(ExprName(Id(var)), e){t*} -> Assign(ExprName(Id(var)), e){TypeState(ts), t*}
        where <typestate-of> e => ts

rules

  OpToCall :
        c#(args){t*} -> Call(c#(args){t*}, args)
        where <is-op-constructor>(c)

  CallToOp :
        Call(c#(args){t*}, _) -> c#(args){t*}
        where <is-op-constructor>(c)

  InvokeToCall :
        Invoke(m, args){t*} -> Call(Invoke(m, args){t*}, args)

  CallToInvoke :
        Call(Invoke(m, args){t*}, _) -> Invoke(m, args){t*}

strategies

  is-op-constructor =
    <elem>(<id>, [
        "Plus",
        "Minus",
        "Mul",
        "Lt",
        "Gt",
        "LtEq",
        "GtEq",
        "Eq",
        "And",
        "Or",
        "Cond"
        ])

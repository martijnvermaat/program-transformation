module typestate/Rules
imports
  typestate/States

signature
  constructors
    Call : Expr * List(Expr) -> Expr

rules

  TypestateVar :
        ExprName(Id(var)){t*} -> ExprName(Id(var)){TypeState(ts), t*}
        where <Typestate>var => ts

  TypestateLiteral :
        Lit(l){t*} -> Lit(l){TypeState(Init), t*}
        where not(<?Null>l <+ <?String(_)>l)

  TypestateLiteral :
        Lit(String(s)){t*} -> Lit(String(s)){TypeState(NotNull), t*}

  TypestateLiteral :
        Lit(Null){t*} -> Lit(Null){TypeState(Null), t*}

  TypestateNewInstance :
        NewInstance(ta, t, e, b){t*} -> NewInstance(ta, t, e, b){TypeState(ts), t*}
        where typestate-instance-init => ts

  TypestateCall :
        Call(f{t*}, e*) -> Call(f{TypeState(ts), t*}, e*)
        where <type-attr> f{t*} => type
              ; <foldr(typestate-call-init(|type), typestate-call-combine, typestate-of)> e* => ts

  TypestateVarAssignment :
        Assign(ExprName(Id(var)), e){t*} -> Assign(ExprName(Id(var)), e){TypeState(ts), t*}
        where <Typestate>var => ts

rules

  OpToCall :
        c#(args){t*} -> Call(c#(args){t*}, args)
        where <is-op-constructor>(c)

  CallToOp :
        Call(c#(args){t*}, _) -> c#(args){t*}
        where <is-op-constructor>(c)

  InvokeToCall :
        Invoke(m, args){t*} -> Call(Invoke(m, args){t*}, args)

  CallToInvoke :
        Call(Invoke(m, args){t*}, _) -> Invoke(m, args){t*}

strategies

  is-op-constructor =
    <elem>(<id>, [
        "Plus",
        "Minus",
        "Mul",
        "Lt",
        "Gt",
        "LtEq",
        "GtEq",
        "Eq",
        "And",
        "Or",
        "Cond"
        ])
